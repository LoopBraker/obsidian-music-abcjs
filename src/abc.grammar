@top Program { (line newline)* line? }

@external tokens lineStartTokens from "./tokens" { InfoKey }

line { 
  // 1. Specific Headers (Priority)
  CommentedDirective | 
  MidiLine |    
  DirectiveLine | 
  VoiceLine |   
  KeyLine |     
  InfoLine |    
  
  // 2. Comments
  Comment | 
  
  // 3. Score (Music) - The Default Fallback
  // If it's not a header or comment, it's music.
  ScoreLine |
  
  // 4. Garbage collector (for safety)
  Other 
}

// === SCORE (MUSIC) ===
// A line of music. It doesn't need a starting keyword.
ScoreLine {
  ( ScoreContent | Space )+ 
  InlineComment?
}

ScoreContent {
  BarComponent |
  Annotation |
  Ornament |
  Duration |
  ComplexNote | 
  SimpleNote  | 
  Rest |
  Spacing |
  MidiNumber |   
  Slash |       
  Word | 
  SingleChar
}

// === MIDI ===
MidiLine { MidiKeyword Space MidiContent (Space MidiContent)* InlineComment? }
MidiContent {
  ProgramAssignment | ChordProgAssignment | ChannelAssignment |
  DrumAssignment | GchordAssignment | TransposeAssignment |
  DrumOnKeyword | DrumOffKeyword | DirectiveArgs | GchordOnKeyword | GchordOffKeyword
}
ProgramAssignment { @specialize<Word, "program"> Space MidiNumber }
ChordProgAssignment { @specialize<Word, "chordprog"> Space MidiNumber }
ChannelAssignment { @specialize<Word, "channel"> Space MidiNumber }
DrumAssignment { @specialize<Word, "drum"> Space Sequence Space MidiNumber }
Sequence {( textIdentifier | MidiNumber )* }
GchordAssignment { @specialize<Word, "gchord"> Space DirectiveArgs }
TransposeAssignment { @specialize<Word, "transpose"> Space MidiNumber }
DrumOnKeyword { @specialize<Word, "drumon"> }
DrumOffKeyword { @specialize<Word, "drumoff"> }
GchordOnKeyword { @specialize<Word, "gchordon"> }
GchordOffKeyword { @specialize<Word, "gchordoff"> }

// === Voice ===
VoiceLine { VoiceKey Space? VoiceName (Space VoiceProperty)* InlineComment? }

VoiceName { 
  // 1. Allow text followed immediately by a number (e.g. "V1", "Violin2")
    (Word | SimpleNote | SingleChar | ComplexNote) (SimpleNote | ComplexNote | Word)? (Duration | MidiNumber)? |
  
  // 2. Fallbacks for other single types
  MidiNumber | Slash | BarComponent | Annotation | Duration
}
VoiceProperty { GenericAssignment | textIdentifier}

// === Key ===
KeyLine { KeyKey Space? KeyTonic (Space KeyProperty)* InlineComment? }

KeyTonic {
  // Option 1: "none" or "HP"
  KeyNone |
  // Option 2: Standard Key
  // Matches C, F#, Bb, Am (if written as word)
  SimpleNote (Sharp)?
}

KeyNone {
  @specialize<Word, "none" | "HP">
}

KeyProperty { GenericAssignment | textIdentifier }

// === Generic Info ===
InfoLine { InfoKey ( Space? InfoVal )* InlineComment? }
InfoVal { textIdentifier | MidiNumber | Slash | BarComponent}

// === Helpers ===
GenericAssignment { 
  AssignmentKey equalsWithSpaces AssignmentValue 
}

AssignmentKey { 
  textIdentifier 
}

AssignmentValue { 
  textIdentifier | MidiNumber 
}

textIdentifier { 
  Word | SimpleNote | Rest | Spacing | SingleChar | Annotation | Duration | ComplexNote | Ornament 
}

// === Directives ===
DirectiveLine { 
  DirectiveKeyword ( Space DirectiveArgs? )? InlineComment? 
}

@tokens {
  newline { "\n" }
  // Directives and Keywords
  MidiKeyword { "%%MIDI" }
  DirectiveKeyword { "%%" ![ \t%\n]+ }
  VoiceKey { "V:" }
  KeyKey { "K:" }

  Sharp { "#" }

  BarComponent { "|" | ":" | "[" | "]" }
  
  // Matches a double quote, followed by anything that ISN'T a newline or quote, ending with a quote.
  Annotation { '"' ![\n"]* '"' }

  // Duration
  Duration { "<" | ">" | "-" | "(" | ")" | ".(" |  ":" | "{" | "}" | "(" $[\t ]* @digit+  | 
            ( @digit + ) | ( "/" + @digit* ) | ( @digit+ "/" @digit* )}
  
  Ornament{ "~" | "." | "u" | "v" }

  // Complex Note
  ComplexNote {
    ( ("^" "^"? | "_" "_"? | "=") $[A-Ga-g] ("'" | ",")* ) | 
    ( $[A-Ga-g] ("'" | ",")+ ) 
  }

  // Word (2+ chars)
  //Word { (@asciiLetter | "+" | "-" | @digit) (@asciiLetter | "+" | "-" | @digit)+ }

   Word { 
    @asciiLetter @asciiLetter (@asciiLetter | "+" | "-" | "_" | @digit)* 
  }

  // SimpleNote (1 char note)
  SimpleNote { $[A-Ga-g] }

  // Rests and Spacing: zZxy
  Rest { $[zZ] }
  Spacing { $[xXy] }

  // SingleChar (1 char fallback)
  SingleChar { @asciiLetter }

  Slash { "/"}
  
  Space { $[\t ]+ }

  equalsWithSpaces { ($[\t ]+ "=" $[\t ]*) | ("=" $[\t ]*) }

  MidiNumber { ("+" | "-")? @digit+ }
  
  DirectiveArgs { ![\s%\n=] ![%\n]* }
  CommentedDirective { "%%%" ![\n]* }
  InlineComment { "%" ![\n]* }
  Comment { "%" ![\n]* }
  Other { ![\n]+ }
  
  @precedence { 
    equalsWithSpaces,
    CommentedDirective,
    MidiKeyword,
    DirectiveKeyword, 
    VoiceKey,
    KeyKey,
    BarComponent,
    Annotation,
    Ornament,
    Duration,
    ComplexNote,
    Word,
    SimpleNote,
    Rest,
    Spacing,
    SingleChar,
    Slash,
    Sharp,
    MidiNumber,
    Space,
    DirectiveArgs,
    Comment, 
    Other 
  }
}