@top Program { (line newline)* line? }

line { 
  CommentedDirective | 
  MidiLine |    // Specific rule for %%MIDI lines
  DirectiveLine | 
  VoiceLine |   // Specific rule for V: lines
  KeyLine |     // Specific rule for K: lines
  CompLine |    // Specific rule for COMP: lines
  InfoLine |    // Generic rule for T:, M:, etc.
  Comment | 
  Other 
}

// === 1. MIDI Line (Strict Parsing) ===
// Example: %%MIDI program 1
MidiLine {
  MidiKeyword
  Space
  MidiContent
  (Space MidiContent)*  // Additional attributes (will be flagged as errors)
  InlineComment?
}

MidiContent {
  ProgramAssignment |
  ChordProgAssignment |
  ChannelAssignment |
  DrumAssignment |
  GchordAssignment |
  TransposeAssignment |
  DrumOnKeyword |
  DrumOffKeyword |
  DirectiveArgs
}

// Matches: program 0-127
ProgramAssignment {
  @specialize<Identifier, "program"> Space MidiNumber
}

// Matches: chordprog 0-127
ChordProgAssignment {
  @specialize<Identifier, "chordprog"> Space MidiNumber
}

// Matches: channel 1 or channel 16
ChannelAssignment {
  @specialize<Identifier, "channel"> Space MidiNumber
}

// Matches: drum <any value>
DrumAssignment {
  @specialize<Identifier, "drum"> Space DirectiveArgs
}

// Matches: gchord <any value>
GchordAssignment {
  @specialize<Identifier, "gchord"> Space DirectiveArgs
}

// Matches: transpose <number>
TransposeAssignment {
  @specialize<Identifier, "transpose"> Space MidiNumber
}

// Standalone keywords (no value)
DrumOnKeyword {
  @specialize<Identifier, "drumon">
}

DrumOffKeyword {
  @specialize<Identifier, "drumoff">
}

// === 2. Voice Line (Strict Parsing) ===
// Example: V: V1 clef=bass shift=C or V:V1 clef=bass shift=C
VoiceLine {
  VoiceKey 
  Space?
  VoiceContent
  (Space VoiceContent)*
  InlineComment?
}

VoiceContent {
  GenericAssignment |
  Identifier // Handles the "V1" or "V2" at start
}

// === 3. Key Line (Strict Parsing) ===
// Example: K: C clef=bass or K:Cmaj clef=treble
KeyLine {
  KeyKey
  Space?
  KeyContent
  (Space KeyContent)*
  InlineComment?
}

KeyContent {
  GenericAssignment |
  Identifier // Handles the key signature like "C", "Cmaj", "Amin", etc.
}

// === 4. COMP Line (Composition Field) ===
// Example: COMP: MusicNotes A B C
// or: COMP: A B C (components can be used directly)
// Spaces are optional: "[FGD" same as "[ F G D"
CompLine {
  CompKey
  Space?
  CompContent
  (Space? CompContent)*
  InlineComment?
}

CompContent {
  BarComponent |
  MusicNoteComponent |
  CompAttribute |
  Identifier // Fallback for other content
}

// Matches: name=value or name = value (for properties other than clef/shift/stem)
GenericAssignment {
  Identifier equalsWithSpaces AttributeValue
}


// === 5. Generic Info Line ===
// Example: T: My Song
InfoLine {
  InfoKey
  ( Space DirectiveArgs? )?
  InlineComment?
}

// === 3. Directives ===
DirectiveLine { 
  DirectiveKeyword 
  ( Space DirectiveArgs? )? 
  InlineComment? 
}


@tokens {
  newline { "\n" }
  
  // -- Keywords --
  MidiKeyword { "%%MIDI" }
  
  DirectiveKeyword { "%%" ![ \t%\n]+ }
  
  // Explicit V:, K:, and COMP: keys to separate them from generic infos
  VoiceKey { "V:" }
  KeyKey { "K:" }
  CompKey { "COMP:" }
  
  // COMP field components and attributes
  // Bar components are single characters and should be matched first
  BarComponent { "|" | ":" | "[" | "]" }
  // Music notes - single letters (A-G, a-g)
  // Not followed by : to avoid matching info keys
  // The lookahead ensures proper tokenization
  MusicNoteComponent { "A" | "B" | "C" | "D" | "E" | "F" | "G" | "a" | "b" | "c" | "d" | "e" | "f" | "g" }
  CompAttribute { "MusicNotes" | "Bar" }
  
// Generic Info key (T:, M:, etc), but NOT V:, K:, or COMP:
// Matches single letter followed by : (excluding V, K, and the start of COMP)
InfoKey { ![VK] @asciiLetter ":" }

  Space { $[\t ]+ }
  
  // Equals with optional spaces on both sides (matches = or spaces = spaces)
  equalsWithSpaces { ($[\t ]+ "=" $[\t ]*) | ("=" $[\t ]*) }
  
  // MIDI numbers (integers, can be negative for transpose)
  MidiNumber { "-"? @digit+ }
  
  // A generic alphanumeric word (includes +/- for treble+8, treble-8)
  Identifier { (@asciiLetter | "+" | "-" | @digit)+ }
  
  // Used for generic properties (name=SomethingElse)
  AttributeValue { (@asciiLetter | "+" | "-" | @digit)+ }

  // -- Generic Args (rest of line) --
  DirectiveArgs { ![\s%\n=] ![%\n]* }
  
  CommentedDirective { "%%%" ![\n]* }
  InlineComment { "%" ![\n]* }
  Comment { "%" ![\n]* }
  Other { ![\n]+ }
  
  // Precedence: 
  // 1. Look for V:, K:, and COMP: first
  // 2. Look for specific Valid tokens before generic Identifiers
  // 3. equals before Space to match = with surrounding spaces
  @precedence { 
    equalsWithSpaces,
    CommentedDirective,
    MidiKeyword,
    DirectiveKeyword, 
    VoiceKey,
    KeyKey,
    CompKey,
    BarComponent,
    MusicNoteComponent,
    CompAttribute,
    InfoKey, 
    MidiNumber,
    Space,
    Identifier,
    DirectiveArgs,
    Comment, 
    Other 
  }
}
