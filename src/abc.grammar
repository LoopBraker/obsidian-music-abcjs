@top Program { (line newline)* line? }

line { 
  CommentedDirective | 
  MidiLine |    // Specific rule for %%MIDI lines
  DirectiveLine | 
  VoiceLine |   // Specific rule for V: lines
  InfoLine |    // Generic rule for T:, M:, etc.
  Comment | 
  Other 
}

// === 1. MIDI Line (Strict Parsing) ===
// Example: %%MIDI program 1
MidiLine {
  MidiKeyword
  Space
  MidiContent
  (Space MidiContent)*  // Additional attributes (will be flagged as errors)
  InlineComment?
}

MidiContent {
  ProgramAssignment |
  ChordProgAssignment |
  ChannelAssignment |
  DrumAssignment |
  GchordAssignment |
  TransposeAssignment |
  DrumOnKeyword |
  DrumOffKeyword |
  DirectiveArgs
}

// Matches: program 0-127
ProgramAssignment {
  @specialize<Identifier, "program"> Space MidiNumber
}

// Matches: chordprog 0-127
ChordProgAssignment {
  @specialize<Identifier, "chordprog"> Space MidiNumber
}

// Matches: channel 1 or channel 16
ChannelAssignment {
  @specialize<Identifier, "channel"> Space MidiNumber
}

// Matches: drum <any value>
DrumAssignment {
  @specialize<Identifier, "drum"> Space DirectiveArgs
}

// Matches: gchord <any value>
GchordAssignment {
  @specialize<Identifier, "gchord"> Space DirectiveArgs
}

// Matches: transpose <number>
TransposeAssignment {
  @specialize<Identifier, "transpose"> Space MidiNumber
}

// Standalone keywords (no value)
DrumOnKeyword {
  @specialize<Identifier, "drumon">
}

DrumOffKeyword {
  @specialize<Identifier, "drumoff">
}

// === 2. Voice Line (Strict Parsing) ===
// Example: V: V1 clef=bass shift=C or V:V1 clef=bass shift=C
VoiceLine {
  VoiceKey 
  Space?
  VoiceContent
  (Space VoiceContent)*
  InlineComment?
}

VoiceContent {
  GenericAssignment |
  Identifier // Handles the "V1" or "V2" at start
}

// Matches: name=value or name = value (for properties other than clef/shift/stem)
GenericAssignment {
  Identifier equalsWithSpaces AttributeValue
}


// === 2. Generic Info Line ===
// Example: T: My Song
InfoLine {
  InfoKey
  ( Space DirectiveArgs? )?
  InlineComment?
}

// === 3. Directives ===
DirectiveLine { 
  DirectiveKeyword 
  ( Space DirectiveArgs? )? 
  InlineComment? 
}


@tokens {
  newline { "\n" }
  
  // -- Keywords --
  MidiKeyword { "%%MIDI" }
  
  DirectiveKeyword { "%%" ![ \t%\n]+ }
  
  // Explicit V: key to separate it from generic infos
  VoiceKey { "V:" } 
  
// Generic Info key (T:, K:, etc), but NOT V:
InfoKey { ![V|\n] ":" }

  Space { $[\t ]+ }
  
  // Equals with optional spaces on both sides (matches = or spaces = spaces)
  equalsWithSpaces { ($[\t ]+ "=" $[\t ]*) | ("=" $[\t ]*) }
  
  // MIDI numbers (integers, can be negative for transpose)
  MidiNumber { "-"? @digit+ }
  
  // A generic alphanumeric word (includes +/- for treble+8, treble-8)
  Identifier { (@asciiLetter | "+" | "-" | @digit)+ }
  
  // Used for generic properties (name=SomethingElse)
  AttributeValue { (@asciiLetter | "+" | "-" | @digit)+ }

  // -- Generic Args (rest of line) --
  DirectiveArgs { ![\s%\n=] ![%\n]* }
  
  CommentedDirective { "%%%" ![\n]* }
  InlineComment { "%" ![\n]* }
  Comment { "%" ![\n]* }
  Other { ![\n]+ }
  
  // Precedence: 
  // 1. Look for V: first
  // 2. Look for specific Valid tokens before generic Identifiers
  // 3. equals before Space to match = with surrounding spaces
  @precedence { 
    equalsWithSpaces,
    CommentedDirective,
    MidiKeyword,
    DirectiveKeyword, 
    VoiceKey, 
    InfoKey, 
    MidiNumber,
    Space,
    Identifier,
    DirectiveArgs,
    Comment, 
    Other 
  }
}
