@top Program { (line newline)* line? }

line { 
  CommentedDirective | 
  DirectiveLine | 
  VoiceLine |   // Specific rule for V: lines
  InfoLine |    // Generic rule for T:, M:, etc.
  Comment | 
  Other 
}

// === 1. Voice Line (Strict Parsing) ===
// Example: V: V1 clef=bass shift=C
VoiceLine {
  VoiceKey 
  (Space VoiceContent)*
  InlineComment?
}

VoiceContent {
  ClefAssignment |
  ShiftAssignment |
  GenericAssignment |
  Identifier // Handles the "V1" or "V2" at start
}

// Matches: clef=bass or clef = bass (valid) OR clef=foo (invalid)
ClefAssignment {
  @specialize<Identifier, "clef"> equalsWithSpaces (ValidClef | InvalidValue)
}

// Matches: shift=C or shift = C (valid) OR shift=Z (invalid)
ShiftAssignment {
  @specialize<Identifier, "shift"> equalsWithSpaces (ValidShift | InvalidValue)
}

// Matches: name=value or name = value (for properties other than clef/shift)
GenericAssignment {
  Identifier equalsWithSpaces AttributeValue
}


// === 2. Generic Info Line ===
// Example: T: My Song
InfoLine {
  InfoKey
  ( Space DirectiveArgs? )?
  InlineComment?
}

// === 3. Directives ===
DirectiveLine { 
  DirectiveKeyword 
  ( Space DirectiveArgs? )? 
  InlineComment? 
}


@tokens {
  newline { "\n" }
  
  // -- Keywords --
  DirectiveKeyword { "%%" ![ \t%\n]+ }
  
  // Explicit V: key to separate it from generic infos
  VoiceKey { "V:" } 
  
// Generic Info key (T:, K:, etc), but NOT V:
InfoKey { ![V|\n] ":" }

  Space { $[\t ]+ }
  
  // Equals with optional spaces on both sides (matches = or spaces = spaces)
  equalsWithSpaces { ($[\t ]+ "=" $[\t ]*) | ("=" $[\t ]*) }
  
  // -- Values --

  // Valid Clefs (Exact match list)
  ValidClef { 
    "treble-8" | "treble+8" | "treble" | 
    "bass3" | "bass" | 
    "alto1" | "alto2" | "alto4" | "alto" | 
    "none" | "perc" 
  }

  // Valid Shift (A through G)
  ValidShift { $[A-G]+ }
  
  // A generic alphanumeric word (includes +/- for treble+8, treble-8)
  Identifier { (@asciiLetter | "+" | "-" | @digit)+ }
  
  // Used for generic properties (name=SomethingElse)
  AttributeValue { (@asciiLetter | "+" | "-" | @digit)+ }
  
  // Catch-all for invalid values in assignments (fallback)
  InvalidValue { (@asciiLetter | "+" | "-" | @digit)+ }

  // -- Generic Args (rest of line) --
  DirectiveArgs { ![\s%\n=] ![%\n]* }
  
  CommentedDirective { "%%%" ![\n]* }
  InlineComment { "%" ![\n]* }
  Comment { "%" ![\n]* }
  Other { ![\n]+ }
  
  // Precedence: 
  // 1. Look for V: first
  // 2. Look for specific Valid tokens before generic Identifiers
  // 3. equals before Space to match = with surrounding spaces
  @precedence { 
    equalsWithSpaces,
    CommentedDirective, 
    DirectiveKeyword, 
    VoiceKey, 
    InfoKey, 
    ValidClef, 
    ValidShift, 
    Space,
    Identifier, 
    InvalidValue,
    Comment, 
    Other 
  }
}
