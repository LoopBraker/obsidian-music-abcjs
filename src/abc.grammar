@top Program { (line newline)* line? }

line { 
  CommentedDirective | 
  MidiLine |    // Specific rule for %%MIDI lines
  DirectiveLine | 
  VoiceLine |   // Specific rule for V: lines
  InfoLine |    // Generic rule for T:, M:, etc.
  Comment | 
  Other 
}

// === 1. MIDI Line (Strict Parsing) ===
// Example: %%MIDI program 1
MidiLine {
  MidiKeyword
  Space
  MidiContent
  (Space MidiContent)*  // Additional attributes (will be flagged as errors)
  InlineComment?
}

MidiContent {
  ProgramAssignment |
  ChordProgAssignment |
  ChannelAssignment |
  DrumAssignment |
  GchordAssignment |
  TransposeAssignment |
  DrumOnKeyword |
  DrumOffKeyword |
  DirectiveArgs
}

// Matches: program 0-127
ProgramAssignment {
  @specialize<Identifier, "program"> Space MidiNumber
}

// Matches: chordprog 0-127
ChordProgAssignment {
  @specialize<Identifier, "chordprog"> Space MidiNumber
}

// Matches: channel 1 or channel 16
ChannelAssignment {
  @specialize<Identifier, "channel"> Space MidiNumber
}

// Matches: drum <any value>
DrumAssignment {
  @specialize<Identifier, "drum"> Space DirectiveArgs
}

// Matches: gchord <any value>
GchordAssignment {
  @specialize<Identifier, "gchord"> Space DirectiveArgs
}

// Matches: transpose <number>
TransposeAssignment {
  @specialize<Identifier, "transpose"> Space MidiNumber
}

// Standalone keywords (no value)
DrumOnKeyword {
  @specialize<Identifier, "drumon">
}

DrumOffKeyword {
  @specialize<Identifier, "drumoff">
}

// === 2. Voice Line (Strict Parsing) ===
// Example: V: V1 clef=bass shift=C or V:V1 clef=bass shift=C
VoiceLine {
  VoiceKey 
  Space?
  VoiceContent
  (Space VoiceContent)*
  InlineComment?
}

VoiceContent {
  ClefAssignment |
  ShiftAssignment |
  StemAssignment |
  GstemAssignment |
  LyricsAssignment |
  DynAssignment |
  PercKeyword |
  UpKeyword |
  DownKeyword |
  MergeKeyword |
  GenericAssignment |
  Identifier // Handles the "V1" or "V2" at start
}

// Matches: clef=bass or clef = bass (valid) OR clef=foo (invalid)
ClefAssignment {
  @specialize<Identifier, "clef"> equalsWithSpaces (ValidClef | InvalidValue)
}

// Matches: shift=C or shift = C (valid) OR shift=Z (invalid)
ShiftAssignment {
  @specialize<Identifier, "shift"> equalsWithSpaces (ValidShift | InvalidValue)
}

// Matches: stem=up or stem=down (valid) OR stem=invalid (invalid)
StemAssignment {
  @specialize<Identifier, "stem"> equalsWithSpaces (ValidStem | InvalidValue)
}

// Matches: gstem=auto or gstem=up or gstem=down
GstemAssignment {
  @specialize<Identifier, "gstem"> equalsWithSpaces (ValidDirection | InvalidValue)
}

// Matches: lyrics=auto or lyrics=up or lyrics=down
LyricsAssignment {
  @specialize<Identifier, "lyrics"> equalsWithSpaces (ValidDirection | InvalidValue)
}

// Matches: dyn=auto or dyn=up or dyn=down
DynAssignment {
  @specialize<Identifier, "dyn"> equalsWithSpaces (ValidDirection | InvalidValue)
}

// Standalone keywords (no value)
PercKeyword {
  @specialize<Identifier, "perc">
}

UpKeyword {
  @specialize<Identifier, "up">
}

DownKeyword {
  @specialize<Identifier, "down">
}

MergeKeyword {
  @specialize<Identifier, "merge">
}

// Matches: name=value or name = value (for properties other than clef/shift/stem)
GenericAssignment {
  Identifier equalsWithSpaces AttributeValue
}


// === 2. Generic Info Line ===
// Example: T: My Song
InfoLine {
  InfoKey
  ( Space DirectiveArgs? )?
  InlineComment?
}

// === 3. Directives ===
DirectiveLine { 
  DirectiveKeyword 
  ( Space DirectiveArgs? )? 
  InlineComment? 
}


@tokens {
  newline { "\n" }
  
  // -- Keywords --
  MidiKeyword { "%%MIDI" }
  
  DirectiveKeyword { "%%" ![ \t%\n]+ }
  
  // Explicit V: key to separate it from generic infos
  VoiceKey { "V:" } 
  
// Generic Info key (T:, K:, etc), but NOT V:
InfoKey { ![V|\n] ":" }

  Space { $[\t ]+ }
  
  // Equals with optional spaces on both sides (matches = or spaces = spaces)
  equalsWithSpaces { ($[\t ]+ "=" $[\t ]*) | ("=" $[\t ]*) }
  
  // -- Values --

  // Valid Clefs (Exact match list)
  ValidClef { 
    "treble-8" | "treble+8" | "treble" | 
    "bass3" | "bass" | 
    "alto1" | "alto2" | "alto4" | "alto" | 
    "none" | "perc" 
  }

  // Valid Shift (A through G)
  ValidShift { $[A-G]+ }
  
  // Valid Stem directions
  ValidStem { "up" | "down" }
  
  // Valid Direction values (for gstem, lyrics, dyn)
  ValidDirection { "auto" | "up" | "down" }
  
  // MIDI numbers (integers, can be negative for transpose)
  MidiNumber { "-"? @digit+ }
  
  // A generic alphanumeric word (includes +/- for treble+8, treble-8)
  Identifier { (@asciiLetter | "+" | "-" | @digit)+ }
  
  // Used for generic properties (name=SomethingElse)
  AttributeValue { (@asciiLetter | "+" | "-" | @digit)+ }
  
  // Catch-all for invalid values in assignments (fallback)
  InvalidValue { (@asciiLetter | "+" | "-" | @digit)+ }

  // -- Generic Args (rest of line) --
  DirectiveArgs { ![\s%\n=] ![%\n]* }
  
  CommentedDirective { "%%%" ![\n]* }
  InlineComment { "%" ![\n]* }
  Comment { "%" ![\n]* }
  Other { ![\n]+ }
  
  // Precedence: 
  // 1. Look for V: first
  // 2. Look for specific Valid tokens before generic Identifiers
  // 3. equals before Space to match = with surrounding spaces
  @precedence { 
    equalsWithSpaces,
    CommentedDirective,
    MidiKeyword,
    DirectiveKeyword, 
    VoiceKey, 
    InfoKey, 
    ValidClef, 
    ValidShift, 
    ValidStem,
    ValidDirection,
    MidiNumber,
    Space,
    Identifier,
    DirectiveArgs,
    InvalidValue,
    Comment, 
    Other 
  }
}
