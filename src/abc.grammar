@top Program { 
  // 1. Read standard lines (V:, K:, T:, %%MIDI) top to bottom
  (HeaderLine newline)* 
  
  // 2. If we hit COMP:, switch to Block mode until the end
  CompBlock? 
}

@external tokens lineStartTokens from "./tokens" { InfoKey }

// Anything that ISN'T the COMP block
HeaderLine { 
  CommentedDirective | 
  MidiLine |    
  DirectiveLine | 
  VoiceLine |   
  KeyLine |     
  InfoLine |    
  Comment | 
  Other 
}

// === COMP BLOCK (Multiline) ===
CompBlock {
  CompKey 
  // Loop accepts Content, Spaces, Comments, AND Newlines
  ( CompContent | Space | newline  | Comment )*
}

CompContent {
  BarComponent |
  ComplexNote | 
  SimpleNote  | 
  MidiNumber |   
  Slash |       
  CompAttribute |
  Word | 
  SingleChar
}

// === MIDI ===
MidiLine { MidiKeyword Space MidiContent (Space MidiContent)* InlineComment? }
MidiContent {
  ProgramAssignment | ChordProgAssignment | ChannelAssignment |
  DrumAssignment | GchordAssignment | TransposeAssignment |
  DrumOnKeyword | DrumOffKeyword | DirectiveArgs 
}
ProgramAssignment { @specialize<Word, "program"> Space MidiNumber }
ChordProgAssignment { @specialize<Word, "chordprog"> Space MidiNumber }
ChannelAssignment { @specialize<Word, "channel"> Space MidiNumber }
DrumAssignment { @specialize<Word, "drum"> Space MidiNumber }
GchordAssignment { @specialize<Word, "gchord"> Space DirectiveArgs }
TransposeAssignment { @specialize<Word, "transpose"> Space MidiNumber }
DrumOnKeyword { @specialize<Word, "drumon"> }
DrumOffKeyword { @specialize<Word, "drumoff"> }

// === Voice ===
VoiceLine { VoiceKey Space? VoiceContent (Space VoiceContent)* InlineComment? }
VoiceContent { GenericAssignment | textIdentifier }

// === Key ===
KeyLine { KeyKey Space? KeyContent (Space KeyContent)* InlineComment? }
KeyContent { GenericAssignment | textIdentifier }



// === Generic Info ===
InfoLine { InfoKey ( Space? InfoVal )* InlineComment? }
InfoVal { Word | SimpleNote | SingleChar | MidiNumber | Slash | BarComponent }

// === Helpers ===
GenericAssignment { 
  AssignmentKey equalsWithSpaces AssignmentValue 
}

AssignmentKey { 
  textIdentifier 
}

AssignmentValue { 
  textIdentifier | MidiNumber 
}

// Helper: Matches any text-like element
textIdentifier { 
  Word | SimpleNote | SingleChar 
}

// === Directives ===
DirectiveLine { 
  DirectiveKeyword ( Space DirectiveArgs? )? InlineComment? 
}

@tokens {
  newline { "\n" }
  MidiKeyword { "%%MIDI" }
  DirectiveKeyword { "%%" ![ \t%\n]+ }
  
  VoiceKey { "V:" }
  KeyKey { "K:" }
  CompKey { "COMP:" }
  
  BarComponent { "|" | ":" | "[" | "]" }
  
  // 1. Complex Note (Highest Priority)
  ComplexNote {
    ( ("^" "^"? | "_" "_"? | "=") $[A-Ga-g] ("'" | ",")* ) | 
    ( $[A-Ga-g] ("'" | ",")+ ) 
  }

  // 2. Word (Strictly 2+ chars). 
  // Captures "clef", "shift", "treble", "CD".
  // Because it is longer than SimpleNote, it wins for words.
  Word { (@asciiLetter | "+" | "-" | @digit) (@asciiLetter | "+" | "-" | @digit)+ }

  // 3. SimpleNote (1 char note)
  SimpleNote { $[A-Ga-gzZxXy] }

  // 4. SingleChar (1 char fallback for H, I, J, k...)
  SingleChar { @asciiLetter }

  Slash { "/" | "-"}
  CompAttribute { "MusicNotes" | "Bar" }
  
  Space { $[\t ]+ }
  equalsWithSpaces { ($[\t ]+ "=" $[\t ]*) | ("=" $[\t ]*) }
  MidiNumber { ("+" | "-")? @digit+ }
  
  DirectiveArgs { ![\s%\n=] ![%\n]* }
  CommentedDirective { "%%%" ![\n]* }
  InlineComment { "%" ![\n]* }
  Comment { "%" ![\n]* }
  Other { ![\n]+ }
  
  @precedence { 
    equalsWithSpaces,
    CommentedDirective,
    MidiKeyword,
    DirectiveKeyword, 
    VoiceKey,
    KeyKey,
    CompKey,
    BarComponent,
    ComplexNote,
    Word,
    SimpleNote,
    SingleChar,
    Slash,
    CompAttribute,
    MidiNumber,
    Space,
    DirectiveArgs,
    Comment, 
    Other 
  }
}